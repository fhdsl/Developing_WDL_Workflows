```{r, include = FALSE}
ottrpal::set_knitr_image_path()
```

# Defining a workflow plan

Our WDL guide will center around building a workflow from scratch. As we build out this workflow step-by-step, you will see what strategies and resources are used to develop a workflow that is iterative, reproducible, and efficient in terms of time and resource used. The goal is to use this workflow to illustrate common lessons in writing WDL workflows.

## Somatic mutation calling workflow

The workflow that we will build is a somatic mutation calling workflow on paired cancer-normal samples. Our workflow is inspired from a somatic mutation calling [workflow](https://github.com/FredHutch/tg-wdl-LILAC-workflow/blob/master/GATK4.1.4.0/GATK4.1.4.0_manta.wdl) by the [Berger Lab](https://research.fredhutch.org/berger/en.html) at the Fred Hutch Cancer Center, and a somatic mutation calling [workflow](https://gatk.broadinstitute.org/hc/en-us/articles/360035894731-Somatic-short-variant-discovery-SNVs-Indels-) by the GATK team at the Broad Institute. The workflow takes in FASTQ-formatted sequencing data from pairs of tumor and normal samples. The workflow then aligns the FASTQs of each sample to the human reference genome, marks PCR duplicates, and recalibrates base quality. As a final step, the workflow performs somatic mutation calling on the tumor and normal samples, comparing the two of them to see how the tumor and normal samples differ from each other.

The workflow schematic:

workflow-schematic-goes-here

The tasks involved:

1.  `BwaMem` aligns the samples to the reference genome.
2.  `MarkDuplicates` marks PCR duplicates.
3.  `ApplyBaseRecalibrator` applies base recalibration.
4.  `Mutect2` performs somatic mutation calling.
5.  `annovar` annotates the called somatic mutations.

## Workflow testing strategy

As we build out our workflow, how do we know it is running correctly besides getting a message such as "Workflow finished with status 'Succeeded'" or an exit code 0? In [software development](https://www.atlassian.com/continuous-delivery/software-testing), it is essential to test your code to see whether it generates the expected output given a specified input. This principle applies into bioinformatics workflow development also:

1.  Unit Testing: We need to incorporate tests to ensure that each task we develop is correct.

2.  End-to-end testing: When we connect all the tasks together to form a workflow, we test that the workflow running end-to-end is correct.

Here are some guidelines for any form of testing:

-   The data you use for testing is representative of "real" data.

-   You have an expectation of what the resulting output is *before* you run your workflow on it. It can be as specific as a MD5 checksum, or vague such as a certain file format.

-   The process is quick to run, ideally in the range of just a few minutes. This often means using a small subset of actual data.

-   The data you use for testing is ideally open access so others can verify your workflow also.

Here is our proposed end-to-end testing strategy: We will use samples from the [Cancer Cell Line Encyclopedia Project](https://sites.broadinstitute.org/ccle/), which are well characterized open access cell lines. In particular, we will use the `xxx` sample that has a KRAS somatic mutation as a tumor sample, and use the `xxx` sample that does *not* have a KRAS somatic mutation as a control sample. We will take pre-aligned BAM files of these two samples, filter for mapped reads a few hundred base pairs around KRAS, and convert them into unmapped FASTQ files. These are our paired test samples, and once they run through the workflow, we would expect to find KRAS somatic mutations. We will discuss unit testing as we write out each task.

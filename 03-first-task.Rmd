```{r, include = FALSE}
ottrpal::set_knitr_image_path()
```

# The first task
Before we write any sort of WDL -- whether it is for somatic mutation calling like we will be going over, or any other bioinformatics task -- we need to understand the building blocks of WDL: Tasks!

As mentioned in the first part of this course, every WDL workflow is made up of at least one task. A task typically has inputs, outputs, runtime attributes, and a command section. You can think of a task as a discrete step in a workflow. It can involve a single call to a single bioinformatics tool, a sequence of bash commands, an inline Python script... almost anything you can do non-interactively in a terminal, you can do in a WDL task. In this section, we will go over the parts of a WDL task in more detail to help us write a task for somatic mutation calling.

## Inputs
The inputs of a task are the files and/or variables you will passing into your task's command section.
```
task bam_to_sam {
  input {
    File input_bam
  }
  command <<<
    samtools view -1bS -@ 15 -o converted.sam ~{input_bam}
  >>>
}
```

At runtime, `~{input_bam}` will be replaced with a path to the file. 

Typically, you will want to include at least one File input in a task, but that isn't a requirement. You can pass most WDL variable types into a task.

### Private inputs
Is there a variable you wish to use in your task section that is based on another input variable, or do not want users to be able to directly overwrite? You can define variables outside the `input {}` section to create variables that function like private variables.

```
task bam_to_sam {
  input {
    File input_bam
  }
  String base_file_name = basename(input_bam, ".bam")
  command <<<
    samtools view -1bS -@ 15 -o ~{base_file_name}.sam ~{input_bam}
  >>>
}
```


## Runtime attributes
The runtime attributes of a task tell the WDL executor important information about how to run the task. They are typically placed in a block below the command section, like so:

```
task bam_to_sam {
  input {
    File input_bam
  }
  String base_file_name = basename(input_bam, ".bam")
  command <<<
    samtools view -1bS -@ 15 -o ~{base_file_name}.sam ~{input_bam}
  >>>
  runtime {
    cpu: 16
    docker: "fredhutch/bwa:0.7.17"
    memory: "48 GB"
  }
}
```

These attributes are often specific to particular backends, so we won't go over all of them here. More information can be found in chapter 5, where we talk about designing for specific backends.

## Command section 
The command section of a WDL task is a bash script that will be run [non-interactively](https://tldp.org/LDP/abs/html/intandnonint.html) by the WDL executor. Although it is helpful to think of tasks as discrete steps in a workflow, that does not mean each task needs to be a single line. You could, for example, call a bioinformatics tool and then reprocess the outputs in the same WDL task. 

If a `docker` runtime attribute is specified, it will execute this bash script in a Docker container made from the image specified, otherwise, it will generally execute the bash script in a container based on a generic Ubuntu-based Docker image.

### Docker images and containers
WDL is built to make use of Docker as it makes handling software dependencies much simpler. Docker images can help address all of these situations: 
* Some software is difficult to install or compile on certain systems
* Some programs have conflicting dependencies
* You may not want to directly install software on your system to prevent it from breaking existing software
* You may not have permission to install software if you are using an institute HPC or other shared resource

When you run a WDL task that has a `docker` runtime attribute, your task will be executed in a Docker container sandbox environment. This container sandbox is derived from a template called a Docker image, which packages installed software in a special filesystem. This is one of the main features of a Docker image -- because a Docker image packages the software you need, you can skip much of the installation and dependency issues associated with using new software, and because you take actions within a Docker container sandbox, it's unlikely for you to "mess up" your main system's files. Although a Docker container is, strictly speaking, not the same as a virtual machine, it is helpful to think of it as one if you are new to Docker. Docker containers are managed by Docker Engine, and the official Docker GUI is called Docker Desktop.

Although you will generally need to be able to run Docker in order to run WDLs, you do not need to know how to create Dockerfiles -- plaintext files which compile Docker images when run via `docker build` -- to write your own WDLs. Most popular bioinformatic software packages already have ready-to-use Docker images available, which you can typically find on [Docker Hub](https://hub.docker.com/search?q=). Other registries include quay.io and the Google Container Registry. With that being said, if you would like to create your own Docker images, there are many tutorials and [guidelines](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/) available online. You can also learn more about the details of Docker (and why they technically aren't virtual machines) in [Docker's official curriculum](https://docker-curriculum.com/#introduction).

### Heredoc-style syntax versus braces syntax
You may see WDLs that use this notation for the command section in a task:

```
task do_something_curly_braces {
  input {
    String some_string
  }
  command {
    some_other_string="FOO"
    echo ${some_string}
    echo $some_other_string
  }
}
```

We recommend using heredoc-style syntax instead:
```
task do_something_carrots {
  input {
    String some_string
  }
  command <<<
    some_other_string="FOO"
    echo ~{some_string}
    echo $some_other_string
  >>>
}
```

Heredoc-style syntax for command sections can be clearer than the alternative, as it makes a clearer distinction between bash variables and WDL variables. This is especially helpful for complicated bash scripts. Heredoc-style syntax is also what the WDL 1.1 spec recommends using in most cases. However, the older non-heredoc style is still perfectly functional for a lot of use cases.

### Referencing variables
Assuming heredoc syntax is being used, a WDL task's input variables are generally referred to in the command section using a tilde (~) and curly braces. To prevent issues with spaces in strings, it is often a good idea to put quotation marks around a string variable, like so:

```
task cowsay {
  input {
    String some_string
  }
  command <<<
    cowsay -t "~{some_string}"
  >>>
  runtime {
    docker: "rancher/cowsay:latest"
  }
}
```

If `some_string` is "hello world" then the command section of this task is interpreted as the following:

```
cowsay -t "hello world"
```

What happens if we had not wrapped `~{some_string}` in quotation marks? If `some_string` was just "hello", it wouldn't matter. But because `some_string` is two words with a space in between, then the script would be interpreted as `cowsay -t hello world` and cause an error, because the cowsay program thinks `world` is another argument. By including quotation marks, `cowsay -t "~{some_string}"` can be interpreted as `cowsay -t "hello world"` and you will correctly get a cow's greeting instead of an error.

If the input variable is an array, we must include an array separator. In WDL 1.0, this is done using the `sep=` expression placeholder. Every value in the WDL Array[String] will be separated by whatever value is declared via `sep`. In this example, that is a simple space, as that is one way how to construct a bash variable.

```
task count_words {
  input {
    Array[String] a_big_sentence
  }
  command <<<
    ARRAY_OF_WORDS=(~{sep=" " a_big_sentence})
    echo ${#ARRAY_OF_FILES[@]} >> length.txt
    # Note how the bash array uses ${} syntax, which could quickly get
    # confusing if we used that syntax for our WDL variables. This is
    # why we recommend using tilde + {} for your WDL variables.
  >>>
}
```
It's usually unnecessary to declare an Array[String], because a single String can have many words in it. That being said, an Array[String] can sometimes come in handy if it is made up of outputs from other tasks. We'll talk more about chaining tasks together in upcoming chapters.

::: {.notice data-latex="warning"}
The WDL 1.1 spec added a new built-in function, `sep()`, which replaces the `sep=` expression placeholder for arrays. This same version of the spec also notes that the `sep=` expression placeholder [are deprecated and will be removed from future versions of WDL](https://github.com/openwdl/wdl/blob/main/versions/1.1/SPEC.md#-expression-placeholder-options). For the time being, we recommend sticking with `sep=` as it is compatible with both WDL 1.0 and WDL 1.1, even though it is technically deprecated in WDL 1.1.
:::

If you're not used to working in bash, the syntax for interacting with bash arrays can be unintuitive, but you don't have to write a WDL's command section only using bash. In fact, working in another language besides bash within a WDL can be a great way to write code quickly, or perform tasks that are more advanced than what a typical bash script can handle. Just be sure to set `sep` properly to ensure that your array is interpreted correctly. In this example, we place quotation marks before and after the variable to ensure that the first and last value of the list are given beginning and ending quotation marks respectively.

```
task count_words_python {
  input {
    Array[String] a_big_sentence
  }
  command <<<
    python << CODE
    sentence = [ "~{sep='", "' a_big_sentence}" ]
    print(len(sentence))
    CODE
  >>>
  runtime {
    docker: "python:latest"
  }
}
```

## Outputs

The outputs of a task are defined in the `output` section of your task. Typically, this will take the form of directly outputting a file that was created in the command section. When these file outputs are referenced in the `output` section, you can refer to their path in the Docker container directly. In this example, because "converted.sam" is in the working directory, we can directly grab that output by name.

```
task bam_to_sam {
  input {
    File input_bam
  }
  command <<<
    samtools view -1bS -@ 15 -o converted.sam ~{input_bam}
  >>>
  runtime {
    cpu: 16
    docker: "fredhutch/bwa:0.7.17"
    memory: "48 GB"
  }
  output {
    File sam_file = "converted.sam"
  }
}
```

If the output was not in the working directory, we would need to change the output to point to the file's path relative to the workdir.

```
task bam_to_sam_in_folder {
  input {
    File input_bam
  }
  command <<<
    mkdir sams
    samtools view -1bS -@ 15 -o converted.sam ~{input_bam}
    mv converted.sam ./sams/converted.sam
  >>>
  runtime {
    cpu: 16
    docker: "fredhutch/bwa:0.7.17"
    memory: "48 GB"
  }
  output {
    File sam_file = "sams/converted.sam"
  }
}
```

You can make our outputs a function of input variables, both those in the `input` section and those declared privately as discussed earlier. This can be helpful if you intend on running this WDL on many different files -- each one will get a unique filename instead of "converted.sam" being the name for all of them.

```
task bam_to_sam_again {
  input {
    File input_bam
  }
  String base_file_name = basename(input_bam, ".bam")
  command <<<
    samtools view -1bS -@ 15 -o ~{base_file_name}.sam ~{input_bam}
  >>>
  runtime {
    cpu: 16
    docker: "fredhutch/bwa:0.7.17"
    memory: "48 GB"
  }
  output {
    File sam_file = base_file_name + ".sam"
  }
}
```

Outputs can (generally, see warning below) also be functions of other outputs in the same task, as long as those outputs are declared first.

```
task add_one {
  input {
    Int some_integer
  }
  command <<<
    echo ~{some_integer} > a.txt
    echo "1" > b.txt
  >>>
  output {
    Int a = read_int("a.txt")
    Int b = read_int("b.txt")
    Int c = a + b
  }
}
```

::: {.notice data-latex="warning"}
Cromwell does not fully support outputs being a function of the same task's other outputs. On the Terra backend, the above code example would cause an error.
:::

To grab multiple outputs at the same time, use glob() to create an array of files. We'll also take this opportunity to demonstrate iterating through a bash array created from an Array[String] input.

```
task one_word_per_file {
  input {
    Array[String] a_big_sentence
  }
  command <<<
    ARRAY_OF_WORDS=(~{sep=" " a_big_sentence})
    i=0
    for word in "${!ARRAY_OF_WORDS[@]}"
    do
      i=$((i+1))
      echo $word >> $i.txt
    done
  >>>
  output {
    Array[File] several_words = glob("*.txt")
  }
}

`glob()` can also be used to grab just one file via `glob("*.txt")[0]` to grab the first thing that matches the glob. This is usually only necessary if you know the extension of an output, but do not have a way of predicting the rest of its filename. Be aware that if anything else in the workdir has the extension you are searching for, you might accidentally grab that one instead of the one you are looking for!

## Putting it all together

<!-- bring it back to the first task of the multi task workflow -->
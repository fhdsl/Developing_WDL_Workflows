```{r, include = FALSE}
ottrpal::set_knitr_image_path()
```

# The first task



## Runtime attributes
The runtime attributes of a task tell the WDL executor important information about how to run the task. These attributes are often specific to particular backends, so we won't go over all of them here, but here are some of the most common ones:





| Attribute      | Fred Hutch HPC                                                                               | Local Cromwell                    | Local miniwdl                     | Terra                                                                                       |
|----------------|----------------------------------------------------------------------------------------------|-----------------------------------|-----------------------------------|---------------------------------------------------------------------------------------------|
| bootDiskSizeGB | n/a                                                                                          | n/a                               | n/a                               | Request a disk of this size to boot the Docker image (useful for very large Docker images)  |
| cpu            | Reserve this many cores (acts as a maximum)                                                  | n/a                               |                                   | Request a minimum of this many cores (scales with memory)                                   |
| disks          |                                                                                              |                                   |                                   |                                                                                             |
| docker         | Run the task in this Docker image                                                            | Run the task in this Docker image | Run the task in this Docker image | Run the task in this Docker image                                                           |
| maxRetries     |                                                                                              |                                   |                                   |                                                                                             |
| memory         | Maximum amount of memory to use                                                              | n/a                               |                                   | Minimum amount of memory to use (scales with CPU)                                           |
| preemptible    | n/a                                                                                          | n/a                               | n/a                               | Attempt running on a preemptible instance this many times, then switch to a non-preemptible |
| walltime       | How much  [walltime](https://en.wikipedia.org/wiki/Elapsed_real_time)  to request for a task | n/a                               | n/a                               | n/a                                                                                         |



## Command section 
The command section of a WDL task is a bash script that will be run by the WDL executor. If a `docker` runtime attribute is specified, it will execute this bash script in a Docker container made from the image specified, otherwise, it will generally execute the bash script in a container based on a generic Ubuntu-based Docker image.

### Docker images and containers
A Docker image is a template from which Docker containers are made. When you run a WDL task that has a `docker` runtime attribute, your task will be executed in a Docker container sandbox environment. A Docker image is described in text by a Dockerfile, which typically has commands for installing software one step at a time, which when executed by `docker build`, will create a Docker image that packages that installed software in a special filesystem. Although a Docker container is, strictly speaking, not the same as a virtual machine, it is helpful to think of it as one if you are new to Docker. Docker containers are managed by Docker Engine, and the official Docker GUI is called Docker Desktop.

WDL is built to make use of Docker as it makes handling software dependencies much simpler. Docker images can help address all of these situations: 
* Some software is difficult to install or compile on certain systems
* Some programs have conflicting dependencies
* You may not want to directly install software on your system to prevent it from breaking existing software
* You may not have permission to install software if you are using an institute HPC or other shared resource

Although you will generally need to be able to run Docker in order to run WDLs, you do not need to know how to create Dockerfiles to write your own WDLs. Most popular bioinformatic software packages already have ready-to-use Docker images available, which you can typically find on [Docker Hub](https://hub.docker.com/search?q=). Other registries include quay.io and the Google Container Registry. With that being said, if you would like to create your own Docker images, there are many tutorials and [guidelines](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/) available online. You can also learn more about the details of Docker (and why they technically aren't virutal machines) in [Docker's official cirriculum](https://docker-curriculum.com/#introduction).

### Heredoc-style syntax versus braces syntax
You may see WDLs that use this notation for the command section in a task:

```
task do_something {
  input {
    String some_string
  }
  command {
    some_other_string="FOO"
    echo ${some_string}
    echo $some_other_string
  }
}
```

We recommend using heredoc-style syntax instead:
```
task do_something {
  input {
    String some_string
  }
  command <<<
    some_other_string="FOO"
    echo ~{some_string}
    echo $some_other_string
  >>>
}
```

Heredoc-style syntax for command sections can be clearer than the alternative, as it makes a clearer distinction between bash variables and WDL variables. This is especially helpful for complicated bash scripts. Heredoc-style syntax is also what the WDL 1.1 spec recommends using in most cases. However, the older non-heredoc style is still perfectly functional for a lot of use cases.

### Referencing variables
Assuming heredoc syntax is being used, a WDL task's input variables are generally referred to in the command section using a tilde (~) and curly braces. To prevent issues with spaces in strings, it is often a good idea to put quotation marks around a string variable, like so:

<!-- TODO: make sure unix cowsay acts like this too, not just the python wrapper I use -->

```
task cowsay {
  input {
    String some_string
  }
  command <<<
    cowsay -t "~{some_string}"
  >>>
}
```
If we had written `cowsay -t ~{some_string}` and `some_string` was `foo bar`, then the script would be intepreted as `cowsay -t foo bar` and cause an error, because the cowsay program thinks `bar` is an argument. By including quotation marks, `cowsay -t "~{some_string}"` can be interpreted as `cowsay -t "foo bar"` and you will correctly get a cow saying "foo bar" instead of an error.

If the input variable is an array, we must include an array seperator. In WDL 1.0, this is done using the `sep=` expression placeholder:

<!-- TODO: array seperator -->

::: {.notice data-latex="warning"}
The WDL 1.1 spec added a new built-in function, `sep()`, which replaces the `sep=` expression placeholder for arrays. This same version of the spec also notes that the `sep=` expression placeholder [are deprecated and will be removed from future versions of WDL](https://github.com/openwdl/wdl/blob/main/versions/1.1/SPEC.md#-expression-placeholder-options). For the time being, we recommend sticking with `sep=` as it is compatiable with both WDL 1.0 and WDL 1.1, even though it is technically deprecated in WDL 1.1.
:::


## Outputs

Outputs can (generally, see warning below) also be functions of other outputs in the same task, as long as those outputs are declared first.

```
task do_something {
  input {
    String some_string
  }
  command <<<
    echo "1" > a.txt
    echo "2" > b.txt
  >>>
  output {
    Int a = read_int("a.txt")
    Int b = read_int("b.txt")
    Int c = a + b
  }
}
```

::: {.notice data-latex="warning"}
Cromwell does not fully support outputs being a function of the same task's other outputs. On the Terra backend, the above code example would cause an error.
:::



